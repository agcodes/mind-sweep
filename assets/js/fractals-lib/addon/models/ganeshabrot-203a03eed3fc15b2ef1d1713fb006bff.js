import CComplex from"./CComplex";import Mandelbrot from"./mandelbrot";import GridAdapterService from"calc-utils/models/grid-adapter-service";export default class Ganeshabrot extends Mandelbrot{constructor(){super(),this.grid=null,this.gridAdapter=new GridAdapterService,this.w=0,this.h=0,this.derivativeCalculation=!1}setParameters(t){this.params=t,this.derivativeCalculation=18==this.params.method||19==this.params.method,this.params.setC0()}initGrid(t,e){this.gridAdapter.setSize(t,e),this.gridAdapter.setLimits(t,e),this.gridAdapter.initPtsMem(32)}getPts(t){const e=[];for(let r=0;r<t.length;r++){const s=this.handlePt(t[r]);if(s&&s.length>0)for(let t=0;t<s.length;t++)s[t]&&e.push(s[t])}return e}handlePt(t){return this.params.ifsParams.mode>0?this.getIfsPts(t):this.getIterationsPts(t)}getIfsPts(t){let e=1===this.params.ifsParams.mode?new CComplex(0,0,0):new CComplex(t[1],t[0],this.params.z0);const r=this.getIFSn(t[1],t[0],this.params.z0);return this.setIterationsPts(e,r,this.iterationsPts,t)}getIterationsPts(t){this.initResults();let e=0;this.it=0;const r=[];let s=this.params.zFromOrigin?new CComplex(0,0,0):new CComplex(t[1],t[0],this.params.z0);const a=null===this.params.c0?new CComplex(t[1],t[0],this.params.z0):this.params.c0,i=this.params.maxIterations,n=this.params.target;let h=this.derivativeCalculation?new CComplex(1,0):null;do{s=this.fZ(s,a,e),this.setMinLp(s),this.derivativeCalculation&&(h=this.derivativeZ(s,a,e).mul(h)),this.addIterationPt(s,e,r),e++}while(this.setResult(s.squaresSum())<n&&e<i);return this.saveZ(s),this.setIterationsPts(s,e,r,t)}addIterationPt(t,e,r){return t&&r.push([t.i,t.r,0,null,this.getIterationValue(t,e)]),r}setIterationsPts(t,e,r,s){if(null===t)return r;switch(this.params.selectMode){case 1:return r=[],e<=this.params.maxIterations&&r.push([s[0],s[1],0,null,this.getIterationValue(t,e)]),r;case 4:if(e===this.params.maxIterations)return r.push([s[0],s[1],0,null,this.getIterationValue(t,e)]),r;break;case 5:if(t.squaresSum()<this.params.target&&e>=this.params.minIterations||e>=this.maxIterations)return r;break;case 6:if(e>=this.params.minIterations&&e<this.params.maxIterations)return r.push([s[0],s[1],0,null,this.getIterationValue(t,e)]),r;break;case 7:if(t.squaresSum()>this.params.target-2&&e>=this.params.minIterations)return r;break;case 9:return e<this.params.maxIterations?(r.push([s[0],s[1],0,this.colorsService.hslToRgb([this.params.drColor[0],this.params.drColor[1],this.params.drColor[2]+5*e]),e]),r):r;case 10:if(e>=this.params.minIterations)return r.push([s[0],s[1],0,this.getIterationValue(new CComplex(s[0],s[1]),e),e]),r;break;default:if(e>=this.params.minIterations)return r.push([s[0],s[1],0,null,this.getIterationValue(t,e)]),r}return null}getIterationValue(t,e){switch(this.params.method){case 1:return e;case 2:return 0===e?0:Math.log(e);case 3:return 1/e*100;case 4:return 0===e?0:Math.sin(Math.log(e))+1;case 5:return e%2==0?0:10;case 7:default:return 1;case 9:return Math.tan(e);case 11:return t.getMagnitude();case 12:return Math.abs(t.getArgument());case 14:return t.squaresSum();case 17:return Math.abs(t.getArgument())*t.squaresSum();case 18:return this.getV(18,e);case 19:return Math.floor(Math.random()*e);case 20:return Math.abs(Math.sin(t.squaresSum()*Math.PI));case 21:return Math.log(Math.abs(t.getArgument()));case 22:return Math.log(t.squaresSum());case 23:return Math.sin(Math.log(e))+1;case 26:return this.colorsService.lerpForPoint(t.r,t.i+e/10,.1);case 32:return this.getV(32,e)}}addSymetricPoints(t){if(this.params.xSymetry){let e=[];for(let r=0;r<t.length;r++)if(t[r][0]>=0&&t[r][1]>=0){const s=this.gridAdapter.getXSymetricPoint(t[r]);s&&(s[4]=t[r][4],s[3]=t[r][3],e.push(s),t[r][3]?this.gridAdapter.incrementInGrid(s,-1):this.gridAdapter.incrementInGrid(s,1e3*t[r][4]))}for(let r=0;r<e.length;r++)t.push(e[r])}return t}handleIterationsPoints(t){const e=[];for(let e=0;e<t.length;e++)t[e][0]>=0&&t[e][1]>=0&&(t[e][3]?this.gridAdapter.incrementInGrid(t[e],-1):this.gridAdapter.incrementInGrid(t[e],1e3*t[e][4]));this.addSymetricPoints(t);for(let r=0;r<t.length;r++)if(t[r][0]>0&&t[r][1]>0)if(t[r][3])e.push(t[r]);else{const s=this.gridAdapter.getValueInGrid(t[r])/1e3,a=this.getColor(s,this.params.minOccurrences,this.params.maxOccurrences,3===this.params.selectMode||8===this.params.selectMode?0:100);a&&(t[r][3]=a,t[r][4]=s,e.push(t[r]))}return e}getColor(t,e,r,s){if(t>e&&t<r){const e=t<s?t/10:Math.log10(t);return this.colorsService.hslToRgb([this.params.drColor[0]+e*this.params.drColor[4],this.params.drColor[1]+e*this.params.drColor[5],this.params.drColor[2]+e*this.params.drColor[6]])}return null}}