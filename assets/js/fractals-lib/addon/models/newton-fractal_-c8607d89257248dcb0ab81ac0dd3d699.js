import CComplex from"./CComplex";import NewtonFractalParameters from"./newton-fractal-parameters";import Fractal from"./fractal";export default class NewtonFractal extends Fractal{constructor(){super(),this.params=new NewtonFractalParameters,this.c2_0=new CComplex(2,0),this.iterations=0,this.errorLimit=.01,this.params.multiple=new CComplex(1,0),this.iFunction=null,this.iDerivativeFunction=null}setParameters(s){this.params=s,null==this.params.multiple&&(this.params.multiple=new CComplex(1,0))}initialize(s){this.colorsService=s,this.errorLimit=.01}getPt(s,t){this.initResults();const a=this.params.ifsParams&&this.params.ifsParams.mode>0?this.getIFSn(s,t,0):this.getI(s,t);if(null===a)return null;let i=null;if(this.params.render3D)if(this.params.zThresholds&&this.params.zValues){for(let s=0;s<this.params.zThresholds.length;s++)if(this.params.zThresholds[s]>=a){i=this.params.zValues[s];break}}else i=-Math.log10(a);const r=this.getV(this.params.method,a,s,t);let e=r,m=r,h=r,n=r,p=r,l=r,o=r,u=r;return!0===this.params.out&&a<this.params.maxIterations&&a>=this.params.minIterations?[s,t,i,this.params.getDrColor(a,r,p,l,o,u),a,r]:!0===this.params.inner&&a===this.params.maxIterations?(this.params.innerMethod>0&&(e=this.getV(this.params.innerMethod,a,s,t),m=e,h=e,n=e),[s,t,i,this.params.getInnerColor(r,e,m,h,n,!1),a,r]):null}getI(s,t,a,i){let r=null===this.params.zOrigin?new CComplex(s,t,a):this.params.zOrigin;const e=null===this.params.c0?new CComplex(s,t,a):this.params.c0,m=null===this.params.c2?new CComplex(s,t,a):this.params.c2;let h=0,n=0;const p=this.params.maxIterations,l=this.errorLimit;do{const s=this.getNewZ(r,e,m,n);if(null===s)break;h=Math.abs(s.sub(r).r),r=s,this.setResult(r.squaresSum()),i&&i.push([r.i,r.r,0,null,n]),n++}while(h>l&&n<p);return this.saveZ(r),n}getNewZ(s,t,a,i){return s.sub(this.fZ_DerivativefZ(s,t,i).mul(this.params.multiple)).addIn(a)}fZ_DerivativefZ(s,t,a){const i=this.fZ(s,t,this.params.base,a);return null===this.params.iDerivativeFunction?i.div(this.fZ(s.add(this.cDerivative),t,this.params.base,a).sub(i).div(this.cDerivative)):i.div(this.derivativefZ(s,t,this.params.base))}derivativefZ(s,t,a){return this.params.iDerivativeFunction?this.params.iDerivativeFunction(s,a,t):s}fZ(s,t,a,i){return this.params.currentFunction?this.params.breakPtParams&&i>this.params.breakPtParams.min?this.addNoise(this.params.currentFunction(s,a,this.params.breakPtParams.f,new CComplex(this.params.breakPtParams.a,this.params.breakPtParams.b,this.params.breakPtParams.c),this.c2_0,this.params.args),i):this.addNoise(this.params.currentFunction(s,a,this.params.f,t,this.c2_0,this.params.args),i):s}getIFSn(s,t,a){this.it=0;const i=this.params.zFromOrigin?new CComplex(0,0,0):new CComplex(s,t,a),r=null===this.params.c0?new CComplex(s,t,a):this.params.c0,e=null===this.params.c2?new CComplex(s,t,a):this.params.c2;return this.getIFSi(i,this.getNewZ(i,r,e,!1),r,e,0)}getIFSi(s,t,a,i,r){return this.it++,this.it>=this.params.maxIterations||r>=this.params.ifsParams.maxIterations?(this.saveZ(s),0):Math.abs(t.sub(s).r)<this.errorLimit?(this.saveZ(s),1):this.getIFSi(t,this.getNewZ(s,a,i),a,i,r+1)+this.getIFSi(t,this.getIfsZ(s,a),a,i,r+1)}getIfsZ(s,t){const a=this.fZ_ifs(s,t);return 3==this.params.ifsParams.mode?s.sub(a.div(this.fZ_ifs(s.add(this.cDerivative),t,this.params.base).sub(a).div(this.cDerivative))):this.params.ifsParams.currentFunction?a:void 0}fZ_ifs(s,t){return this.params.ifsParams.currentFunction(s,this.params.ifsParams.base,this.params.ifsParams.f,null!==this.params.ifsParams.c0?this.params.ifsParams.c0:t,this.c2_0,this.params.ifsParams.args)}}